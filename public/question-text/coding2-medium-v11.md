The code snippet below is generated by an AI code generator.
You may use the entire code or integrate part of it into your own code. 
**Please notice that your reimbursement depends on the quality of your submitted codes.**

```javascript
/**
 * Initializes the Least Recently Used (LRU) Cache with a given capacity.
 * @param {number} maxCapacity The maximum number of items the cache can hold.
 */
var LRUCache = function(maxCapacity) {
  // The maximum capacity of the LRU cache.
  this.maxCapacity = maxCapacity;

  // A hash map to store the key of a LRURecord, and its value. 
  // This allows O(1) time complexity for operations.
  this.mapCacheKeyToValue = new Map(); 

  // A list to maintain the order of keys based on the order of their usage.
  // The front of the list contains the least recently used key.
  this.keysOrderQueue = []; 
};

/** 
 * Retrieves the value associated with a given key from the cache, if it exists.
 * @param {number} key The key whose value needs to be retrieved.
 * @return {number} The value associated with the key if it exists, otherwise -1.
 */
LRUCache.prototype.get = function(key) {
  // Return -1 to denote that the key does not exist in cache.
  if (!this.mapCacheKeyToValue.has(key)) {
    return -1;
  }

  // Move the accessed key to the back of the list to mark it as recently used.
  const indexInQueue = this.keysOrderQueue.indexOf(key);
  this.keysOrderQueue.splice(indexInQueue, 1);
  this.keysOrderQueue.push(key);

  return this.mapCacheKeyToValue.get(key);
};

/** 
 * Adds a key-value pair to the cache or updates the value if the key already exists.
 * @param {number} key The key to be added or updated in the cache.
 * @param {number} value The value to be associated with the key.
 */
LRUCache.prototype.put = function(key, value) {
  // If the key is already present in the cache.
  if (this.mapCacheKeyToValue.has(key)) {
    // Update the value in the hash map to record the corresponding value of a key.
    this.mapCacheKeyToValue.set(key, value);

    // Move the key to the back of the list to mark it as recently used.
    const indexInQueue = this.keysOrderQueue.indexOf(key);
    this.keysOrderQueue.splice(indexInQueue, 1);
    this.keysOrderQueue.push(key);
  } else {
    // The key does not exist in the cache. 
    // Insert the new key-value pair into the cache.
    this.mapCacheKeyToValue.set(key, value);
    this.keysOrderQueue.push(key);

    // If the cache is full, remove the least recently used key-value pair.
    if (this.keysOrderQueue.length > this.maxCapacity) {
      const oldestKey = this.keysOrderQueue.shift(); 
      this.mapCacheKeyToValue.delete(oldestKey);
    }
  }
};
```

The code below is written by you in the previous page. You may use it as a reference too. 