Now, you can modify your previous code.  The code snippet below is generated by an AI code generator. You may use the entire code or integrate part of it into your own code. 



<span style="color: red;">**Please notice that your payment depends on the quality of your final submitted codes.**</span> You will receive ***3.5 GBP*** for ***high-quality codes*** and only ***2.5 GBP*** for ***low-quality codes***. The additional 1 pound reward for high-quality code will be paid as a bonus to your Prolific account.  

```javascript
/**
 * Initializes the Least Recently Used (LRU) Cache with a given capacity.
 * @param {number} capacity The maximum number of items the cache can hold.
 */
var LRUCache = function(capacity) {
  // The maximum capacity of the LRU cache.
  this.capacity = capacity;

  // A hash map to store the key of a LRURecord, and its value. 
  // This allows O(1) time complexity for operations.
  this.cache = new Map(); 

  // A list to maintain the order of keys based on the order of their usage.
  // The front of the list contains the least recently used key.
  this.queue = []; 
};

/** 
 * Retrieves the value associated with a given key from the cache, if it exists.
 * @param {number} key The key whose value needs to be retrieved.
 * @return {number} The value associated with the key if it exists, otherwise -1.
 */
LRUCache.prototype.get = function(key) {
  // Return -1 to denote that the key does not exist in cache.
  if (!this.cache.has(key)) {
    return -1;
  }

  // Move the accessed key to the back of the list to mark it as recently used.
  const index = this.queue.indexOf(key);
  this.queue.splice(index, 1);
  this.queue.push(key);

  return this.cache.get(key);
};

/** 
 * Adds a key-value pair to the cache or updates the value if the key already exists.
 * @param {number} key The key to be added or updated in the cache.
 * @param {number} value The value to be associated with the key.
 */
LRUCache.prototype.put = function(key, value) {
  // If the key is already present in the cache.
  if (this.cache.has(key)) {
    // Update the value in the hash map to record the corresponding value of a key.
    this.cache.set(key, value);

    // Move the key to the back of the list to mark it as recently used.
    const index = this.queue.indexOf(key);
    this.queue.splice(index, 1);
    this.queue.push(key);
  } else {
    // The key does not exist in the cache. 
    // Insert the new key-value pair into the cache.
    this.cache.set(key, value);
    this.queue.push(key);

    // If the cache is full, remove the least recently used key-value pair.
    if (this.queue.length > this.capacity) {
      const old = this.queue.shift(); 
      this.cache.delete(old);
    }
  }
};
```

The code below is written by you in the previous page. You may use it as a reference too. 